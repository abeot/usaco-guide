---
id: cf-1891F
source: CF
title: A Growing Tree
author: Albert Cao
---

[Official Editorial](https://codeforces.com/blog/entry/121876)

## Implementation

**Time Complexity:** $\mathcal{O}(q\log q)$, where there are $q$ queries.

<LanguageSection>

<CPPSection>

```cpp
#include <bits/stdc++.h>

typedef long long ll;

using namespace std;

template <class T> class SumSegmentTree {
  private:
	const T DEFAULT = 0;

	int len;
	vector<T> segtree;

	T combine(const T &a, const T &b) { return a + b; }

	void build(const vector<T> &arr, int at, int at_left, int at_right) {
		if (at_left == at_right) {
			segtree[at] = arr[at_left];
			return;
		}
		int mid = (at_left + at_right) / 2;
		build(arr, 2 * at, at_left, mid);
		build(arr, 2 * at + 1, mid + 1, at_right);
		segtree[at] = combine(segtree[2 * at], segtree[2 * at + 1]);
	}

	void set(int ind, T val, int at, int at_left, int at_right) {
		if (at_left == at_right) {
			segtree[at] = val;
			return;
		}
		int mid = (at_left + at_right) / 2;
		if (ind <= mid) {
			set(ind, val, 2 * at, at_left, mid);
		} else {
			set(ind, val, 2 * at + 1, mid + 1, at_right);
		}
		segtree[at] = combine(segtree[2 * at], segtree[2 * at + 1]);
	}

	T range_sum(int start, int end, int at, int at_left, int at_right) {
		if (at_right < start || end < at_left) { return DEFAULT; }
		if (start <= at_left && at_right <= end) { return segtree[at]; }
		int mid = (at_left + at_right) / 2;
		T left_res = range_sum(start, end, 2 * at, at_left, mid);
		T right_res = range_sum(start, end, 2 * at + 1, mid + 1, at_right);
		return combine(left_res, right_res);
	}

  public:
	SumSegmentTree(int len) : len(len) { segtree = vector<T>(len * 4, DEFAULT); };

	SumSegmentTree(const vector<T> &arr) : len(arr.size()) {
		segtree = vector<T>(len * 4, DEFAULT);
		build(arr, 1, 0, len - 1);
	}

	void set(int ind, T val) { set(ind, val, 1, 0, len - 1); }

	T range_sum(int start, int end) { return range_sum(start, end, 1, 0, len - 1); }
};

const ll INF = 1e18;

void solve() {
	int q;
	cin >> q;

	vector<pair<int, ll>> upds;
	int sz = 1;
	vector<vector<int>> adj(q + 2);
	for (int i = 1; i <= q; ++i) {
		int t;
		cin >> t;
		if (t == 1) {
			// vertex added
			int v;
			cin >> v;
			sz++;
			adj[v].push_back(sz);
			adj[sz].push_back(v);
			upds.push_back({sz, -INF});
		} else {
			// sum update
			int v;
			ll x;
			cin >> v >> x;
			upds.push_back({v, x});
		}
	}

	int time = 0;
	vector<int> start(sz + 2, 0);
	vector<int> end(sz + 2, 0);
	function<void(int, int)> euler = [&](int cur, int par) {
		start[cur] = time++;

		for (int x : adj[cur]) {
			if (x == par) continue;
			euler(x, cur);
		}

		end[cur] = time;
	};
	euler(1, -1);

	vector<ll> vals(sz + 2, 0);
	SumSegmentTree<ll> segtree(vals);

	for (int i = 0; i < q; ++i) {
		pair<int, ll> here = upds[i];

		if (upds[i].second == -INF) {
			// set first dude to zero
			int node = upds[i].first;
			int tl = start[node];
			int tr = end[node];

			ll curval = segtree.range_sum(0, start[node]);
			ll tlval = segtree.range_sum(tl, tl);
			ll trval = segtree.range_sum(tr, tr);

			segtree.set(tl, tlval - curval);
			segtree.set(tr, trval + curval);  // update entire subtree, why not
		} else {
			int node = upds[i].first;
			int tl = start[node];
			int tr = end[node];

			ll tlval = segtree.range_sum(tl, tl);
			ll trval = segtree.range_sum(tr, tr);
			segtree.set(tl, tlval + here.second);
			segtree.set(tr, trval - here.second);
		}
	}

	for (int i = 1; i <= sz; ++i) {
		ll curval = segtree.range_sum(0, start[i]);

		cout << curval << " ";
	}
	cout << "\n";
}

int main() {
	ios::sync_with_stdio(0);
	cin.tie(0);

	int t = 1;
	cin >> t;
	while (t--) {
		solve();
		// cout << "DONE\n";
	}
}
```

</CPPSection>

</LanguageSection>
